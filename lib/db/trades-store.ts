/**
 * Trades Store - CRUD operations for trade data
 */

import { Trade } from '../models/trade'
import { STORES, INDEXES, withReadTransaction, withWriteTransaction, promisifyRequest } from './index'

/**
 * Extended trade with block association
 */
export interface StoredTrade extends Trade {
  blockId: string
  id?: number // Auto-generated by IndexedDB
}

/**
 * Add trades for a block (batch operation)
 */
export async function addTrades(blockId: string, trades: Trade[]): Promise<void> {
  if (trades.length === 0) return

  await withWriteTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES)

    // Use Promise.all for better performance with large datasets
    const promises = trades.map(trade => {
      const storedTrade: StoredTrade = { ...trade, blockId }
      return promisifyRequest(store.add(storedTrade))
    })

    await Promise.all(promises)
  })
}

/**
 * Get all trades for a block
 */
export async function getTradesByBlock(blockId: string): Promise<StoredTrade[]> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES)
    const index = store.index(INDEXES.TRADES_BY_BLOCK)
    const result = await promisifyRequest(index.getAll(blockId))

    // Sort by date opened (chronological order)
    return result.sort((a, b) => {
      const dateA = new Date(a.dateOpened).getTime()
      const dateB = new Date(b.dateOpened).getTime()
      if (dateA !== dateB) return dateA - dateB

      // If same date, sort by time
      return a.timeOpened.localeCompare(b.timeOpened)
    })
  })
}

/**
 * Get trades by date range for a block
 */
export async function getTradesByDateRange(
  blockId: string,
  startDate: Date,
  endDate: Date
): Promise<StoredTrade[]> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES)
    const index = store.index('composite_block_date')

    // Create compound key range [blockId, startDate] to [blockId, endDate]
    const range = IDBKeyRange.bound(
      [blockId, startDate],
      [blockId, endDate],
      false,
      false
    )

    const result = await promisifyRequest(index.getAll(range))
    return result
  })
}

/**
 * Get trades by strategy for a block
 */
export async function getTradesByStrategy(blockId: string, strategy: string): Promise<StoredTrade[]> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES)
    const blockIndex = store.index(INDEXES.TRADES_BY_BLOCK)
    const blockTrades = await promisifyRequest(blockIndex.getAll(blockId))

    // Filter by strategy (IndexedDB doesn't support compound queries easily)
    return blockTrades.filter(trade => trade.strategy === strategy)
  })
}

/**
 * Get unique strategies for a block
 */
export async function getStrategiesByBlock(blockId: string): Promise<string[]> {
  const trades = await getTradesByBlock(blockId)
  const strategies = new Set(trades.map(trade => trade.strategy))
  return Array.from(strategies).sort()
}

/**
 * Get trade count by block
 */
export async function getTradeCountByBlock(blockId: string): Promise<number> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES)
    const index = store.index(INDEXES.TRADES_BY_BLOCK)
    const result = await promisifyRequest(index.count(blockId))
    return result
  })
}

/**
 * Delete all trades for a block
 */
export async function deleteTradesByBlock(blockId: string): Promise<void> {
  await withWriteTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES)
    const index = store.index(INDEXES.TRADES_BY_BLOCK)
    const request = index.openCursor(IDBKeyRange.only(blockId))

    await new Promise<void>((resolve, reject) => {
      request.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result
        if (cursor) {
          cursor.delete()
          cursor.continue()
        } else {
          resolve()
        }
      }
      request.onerror = () => reject(request.error)
    })
  })
}

/**
 * Update trades for a block (replace all)
 */
export async function updateTradesForBlock(blockId: string, trades: Trade[]): Promise<void> {
  await withWriteTransaction(STORES.TRADES, async (transaction) => {
    // First delete existing trades
    const store = transaction.objectStore(STORES.TRADES)
    const index = store.index(INDEXES.TRADES_BY_BLOCK)
    const deleteRequest = index.openCursor(IDBKeyRange.only(blockId))

    await new Promise<void>((resolve, reject) => {
      deleteRequest.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result
        if (cursor) {
          cursor.delete()
          cursor.continue()
        } else {
          resolve()
        }
      }
      deleteRequest.onerror = () => reject(deleteRequest.error)
    })

    // Then add new trades
    const promises = trades.map(trade => {
      const storedTrade: StoredTrade = { ...trade, blockId }
      return promisifyRequest(store.add(storedTrade))
    })

    await Promise.all(promises)
  })
}

/**
 * Get trade statistics for a block (aggregated)
 */
export async function getTradeStatistics(blockId: string): Promise<{
  totalTrades: number
  totalPl: number
  winningTrades: number
  losingTrades: number
  totalCommissions: number
  dateRange: { start: Date | null; end: Date | null }
  strategies: string[]
}> {
  const trades = await getTradesByBlock(blockId)

  if (trades.length === 0) {
    return {
      totalTrades: 0,
      totalPl: 0,
      winningTrades: 0,
      losingTrades: 0,
      totalCommissions: 0,
      dateRange: { start: null, end: null },
      strategies: [],
    }
  }

  const totalTrades = trades.length
  const totalPl = trades.reduce((sum, trade) => sum + trade.pl, 0)
  const winningTrades = trades.filter(trade => trade.pl > 0).length
  const losingTrades = trades.filter(trade => trade.pl < 0).length
  const totalCommissions = trades.reduce(
    (sum, trade) => sum + trade.openingCommissionsFees + trade.closingCommissionsFees,
    0
  )

  // Get date range
  const dates = trades.map(trade => new Date(trade.dateOpened))
  const start = new Date(Math.min(...dates.map(d => d.getTime())))
  const end = new Date(Math.max(...dates.map(d => d.getTime())))

  // Get unique strategies
  const strategies = Array.from(new Set(trades.map(trade => trade.strategy))).sort()

  return {
    totalTrades,
    totalPl,
    winningTrades,
    losingTrades,
    totalCommissions,
    dateRange: { start, end },
    strategies,
  }
}

/**
 * Search trades by text (strategy, legs, reason for close)
 */
export async function searchTrades(blockId: string, query: string): Promise<StoredTrade[]> {
  const trades = await getTradesByBlock(blockId)
  const lowerQuery = query.toLowerCase()

  return trades.filter(trade =>
    trade.strategy.toLowerCase().includes(lowerQuery) ||
    trade.legs.toLowerCase().includes(lowerQuery) ||
    (trade.reasonForClose && trade.reasonForClose.toLowerCase().includes(lowerQuery))
  )
}

/**
 * Get trades with pagination
 */
export async function getTradesPage(
  blockId: string,
  offset: number,
  limit: number
): Promise<{ trades: StoredTrade[]; total: number }> {
  const allTrades = await getTradesByBlock(blockId)
  const total = allTrades.length
  const trades = allTrades.slice(offset, offset + limit)

  return { trades, total }
}

/**
 * Export trades to CSV format (for backup/analysis)
 */
export async function exportTradesToCSV(blockId: string): Promise<string> {
  const trades = await getTradesByBlock(blockId)

  if (trades.length === 0) {
    return ''
  }

  // CSV headers
  const headers = [
    'Date Opened', 'Time Opened', 'Opening Price', 'Legs', 'Premium',
    'Closing Price', 'Date Closed', 'Time Closed', 'Avg. Closing Cost',
    'Reason For Close', 'P/L', 'No. of Contracts', 'Funds at Close',
    'Margin Req.', 'Strategy', 'Opening Commissions + Fees',
    'Closing Commissions + Fees', 'Opening Short/Long Ratio',
    'Closing Short/Long Ratio', 'Opening VIX', 'Closing VIX',
    'Gap', 'Movement', 'Max Profit', 'Max Loss'
  ]

  // Convert trades to CSV rows
  const rows = trades.map(trade => {
    // Format dateOpened - handle both Date objects and strings
    const dateOpened = trade.dateOpened instanceof Date
      ? trade.dateOpened.toISOString().split('T')[0]
      : typeof trade.dateOpened === 'string'
        ? new Date(trade.dateOpened).toISOString().split('T')[0]
        : trade.dateOpened;

    return [
    dateOpened,
    trade.timeOpened,
    trade.openingPrice.toString(),
    trade.legs,
    trade.premium.toString(),
    trade.closingPrice?.toString() || '',
    trade.dateClosed instanceof Date
      ? trade.dateClosed.toISOString().split('T')[0]
      : typeof trade.dateClosed === 'string' && trade.dateClosed !== ''
        ? new Date(trade.dateClosed).toISOString().split('T')[0]
        : '',
    trade.timeClosed || '',
    trade.avgClosingCost?.toString() || '',
    trade.reasonForClose || '',
    trade.pl.toString(),
    trade.numContracts.toString(),
    trade.fundsAtClose.toString(),
    trade.marginReq.toString(),
    trade.strategy,
    trade.openingCommissionsFees.toString(),
    trade.closingCommissionsFees.toString(),
    trade.openingShortLongRatio.toString(),
    trade.closingShortLongRatio?.toString() || '',
    trade.openingVix?.toString() || '',
    trade.closingVix?.toString() || '',
    trade.gap?.toString() || '',
    trade.movement?.toString() || '',
    trade.maxProfit?.toString() || '',
    trade.maxLoss?.toString() || ''
  ]
  })

  // Combine headers and rows
  const csvContent = [headers, ...rows]
    .map(row => row.map(field => `"${field}"`).join(','))
    .join('\n')

  return csvContent
}