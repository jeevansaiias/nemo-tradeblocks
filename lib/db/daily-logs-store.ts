/**
 * Daily Logs Store - CRUD operations for daily log data
 */

import { DailyLogEntry } from '../models/daily-log'
import { STORES, INDEXES, withReadTransaction, withWriteTransaction, promisifyRequest } from './index'

/**
 * Extended daily log entry with block association
 */
export interface StoredDailyLogEntry extends DailyLogEntry {
  blockId: string
  id?: number // Auto-generated by IndexedDB
}

/**
 * Add daily log entries for a block (batch operation)
 */
export async function addDailyLogEntries(blockId: string, entries: DailyLogEntry[]): Promise<void> {
  if (entries.length === 0) return

  await withWriteTransaction(STORES.DAILY_LOGS, async (transaction) => {
    const store = transaction.objectStore(STORES.DAILY_LOGS)

    // Use Promise.all for better performance with large datasets
    const promises = entries.map(entry => {
      const storedEntry: StoredDailyLogEntry = { ...entry, blockId }
      return promisifyRequest(store.add(storedEntry))
    })

    await Promise.all(promises)
  })
}

/**
 * Get all daily log entries for a block
 */
export async function getDailyLogsByBlock(blockId: string): Promise<StoredDailyLogEntry[]> {
  return withReadTransaction(STORES.DAILY_LOGS, async (transaction) => {
    const store = transaction.objectStore(STORES.DAILY_LOGS)
    const index = store.index(INDEXES.DAILY_LOGS_BY_BLOCK)
    const result = await promisifyRequest(index.getAll(blockId))

    // Sort by date (chronological order)
    return result.sort((a, b) => {
      const dateA = new Date(a.date).getTime()
      const dateB = new Date(b.date).getTime()
      return dateA - dateB
    })
  })
}

/**
 * Get daily log entries by date range for a block
 */
export async function getDailyLogsByDateRange(
  blockId: string,
  startDate: Date,
  endDate: Date
): Promise<StoredDailyLogEntry[]> {
  return withReadTransaction(STORES.DAILY_LOGS, async (transaction) => {
    const store = transaction.objectStore(STORES.DAILY_LOGS)
    const index = store.index('composite_block_date')

    // Create compound key range [blockId, startDate] to [blockId, endDate]
    const range = IDBKeyRange.bound(
      [blockId, startDate],
      [blockId, endDate],
      false,
      false
    )

    const result = await promisifyRequest(index.getAll(range))
    return result
  })
}

/**
 * Get daily log entry for a specific date
 */
export async function getDailyLogByDate(blockId: string, date: Date): Promise<StoredDailyLogEntry | null> {
  const entries = await getDailyLogsByDateRange(blockId, date, date)
  return entries.length > 0 ? entries[0] : null
}

/**
 * Get daily log count by block
 */
export async function getDailyLogCountByBlock(blockId: string): Promise<number> {
  return withReadTransaction(STORES.DAILY_LOGS, async (transaction) => {
    const store = transaction.objectStore(STORES.DAILY_LOGS)
    const index = store.index(INDEXES.DAILY_LOGS_BY_BLOCK)
    const result = await promisifyRequest(index.count(blockId))
    return result
  })
}

/**
 * Delete all daily log entries for a block
 */
export async function deleteDailyLogsByBlock(blockId: string): Promise<void> {
  await withWriteTransaction(STORES.DAILY_LOGS, async (transaction) => {
    const store = transaction.objectStore(STORES.DAILY_LOGS)
    const index = store.index(INDEXES.DAILY_LOGS_BY_BLOCK)
    const request = index.openCursor(IDBKeyRange.only(blockId))

    await new Promise<void>((resolve, reject) => {
      request.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result
        if (cursor) {
          cursor.delete()
          cursor.continue()
        } else {
          resolve()
        }
      }
      request.onerror = () => reject(request.error)
    })
  })
}

/**
 * Update daily log entries for a block (replace all)
 */
export async function updateDailyLogsForBlock(blockId: string, entries: DailyLogEntry[]): Promise<void> {
  await withWriteTransaction(STORES.DAILY_LOGS, async (transaction) => {
    // First delete existing entries
    const store = transaction.objectStore(STORES.DAILY_LOGS)
    const index = store.index(INDEXES.DAILY_LOGS_BY_BLOCK)
    const deleteRequest = index.openCursor(IDBKeyRange.only(blockId))

    await new Promise<void>((resolve, reject) => {
      deleteRequest.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result
        if (cursor) {
          cursor.delete()
          cursor.continue()
        } else {
          resolve()
        }
      }
      deleteRequest.onerror = () => reject(deleteRequest.error)
    })

    // Then add new entries
    const promises = entries.map(entry => {
      const storedEntry: StoredDailyLogEntry = { ...entry, blockId }
      return promisifyRequest(store.add(storedEntry))
    })

    await Promise.all(promises)
  })
}

/**
 * Get daily log statistics for a block
 */
export async function getDailyLogStatistics(blockId: string): Promise<{
  totalEntries: number
  dateRange: { start: Date | null; end: Date | null }
  finalPortfolioValue: number
  maxDrawdown: number
  totalPl: number
  avgDailyPl: number
}> {
  const entries = await getDailyLogsByBlock(blockId)

  if (entries.length === 0) {
    return {
      totalEntries: 0,
      dateRange: { start: null, end: null },
      finalPortfolioValue: 0,
      maxDrawdown: 0,
      totalPl: 0,
      avgDailyPl: 0,
    }
  }

  const totalEntries = entries.length

  // Get date range
  const dates = entries.map(entry => new Date(entry.date))
  const start = new Date(Math.min(...dates.map(d => d.getTime())))
  const end = new Date(Math.max(...dates.map(d => d.getTime())))

  // Final portfolio value (last entry)
  const sortedEntries = entries.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
  const finalPortfolioValue = sortedEntries[0]?.netLiquidity || 0

  // Calculate max drawdown (most negative value)
  const maxDrawdown = Math.min(...entries.map(entry => entry.drawdownPct))

  // Total P/L (sum of all daily P/L)
  const totalPl = entries.reduce((sum, entry) => sum + entry.dailyPl, 0)

  // Average daily P/L
  const avgDailyPl = totalPl / totalEntries

  return {
    totalEntries,
    dateRange: { start, end },
    finalPortfolioValue,
    maxDrawdown,
    totalPl,
    avgDailyPl,
  }
}

/**
 * Get portfolio value over time (for charts)
 */
export async function getPortfolioValueTimeSeries(blockId: string): Promise<Array<{
  date: Date
  netLiquidity: number
  dailyPl: number
  drawdownPct: number
}>> {
  const entries = await getDailyLogsByBlock(blockId)

  return entries.map(entry => ({
    date: new Date(entry.date),
    netLiquidity: entry.netLiquidity,
    dailyPl: entry.dailyPl,
    drawdownPct: entry.drawdownPct,
  }))
}

/**
 * Get daily P/L aggregated by month
 */
export async function getMonthlyPl(blockId: string): Promise<Record<string, number>> {
  const entries = await getDailyLogsByBlock(blockId)
  const monthlyPl: Record<string, number> = {}

  entries.forEach(entry => {
    const date = new Date(entry.date)
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`

    if (!monthlyPl[monthKey]) {
      monthlyPl[monthKey] = 0
    }
    monthlyPl[monthKey] += entry.dailyPl
  })

  return monthlyPl
}

/**
 * Get daily P/L aggregated by week
 */
export async function getWeeklyPl(blockId: string): Promise<Record<string, number>> {
  const entries = await getDailyLogsByBlock(blockId)
  const weeklyPl: Record<string, number> = {}

  entries.forEach(entry => {
    const date = new Date(entry.date)
    const year = date.getFullYear()
    const week = getWeekNumber(date)
    const weekKey = `${year}-W${String(week).padStart(2, '0')}`

    if (!weeklyPl[weekKey]) {
      weeklyPl[weekKey] = 0
    }
    weeklyPl[weekKey] += entry.dailyPl
  })

  return weeklyPl
}

/**
 * Export daily logs to CSV format
 */
export async function exportDailyLogsToCSV(blockId: string): Promise<string> {
  const entries = await getDailyLogsByBlock(blockId)

  if (entries.length === 0) {
    return ''
  }

  // CSV headers
  const headers = [
    'Date', 'Net Liquidity', 'Current Funds', 'Withdrawn',
    'Trading Funds', 'P/L', 'P/L %', 'Drawdown %'
  ]

  // Convert entries to CSV rows
  const rows = entries.map(entry => [
    entry.date instanceof Date ? entry.date.toISOString().split('T')[0] : entry.date,
    entry.netLiquidity.toString(),
    entry.currentFunds.toString(),
    entry.withdrawn.toString(),
    entry.tradingFunds.toString(),
    entry.dailyPl.toString(),
    entry.dailyPlPct.toString(),
    entry.drawdownPct.toString()
  ])

  // Combine headers and rows
  const csvContent = [headers, ...rows]
    .map(row => row.map(field => `"${field}"`).join(','))
    .join('\n')

  return csvContent
}

/**
 * Helper function to get week number
 */
function getWeekNumber(date: Date): number {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()))
  const dayNum = d.getUTCDay() || 7
  d.setUTCDate(d.getUTCDate() + 4 - dayNum)
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1))
  return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7)
}